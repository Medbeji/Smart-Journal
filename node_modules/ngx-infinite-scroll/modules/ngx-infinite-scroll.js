import { Directive, ElementRef, EventEmitter, Injectable, Input, NgModule, NgZone, Output } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/sampleTime';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/mergeMap';

class AxisResolverFactory {
    constructor() { }
    /**
     * @param {?=} vertical
     * @return {?}
     */
    create(vertical = true) {
        return new AxisResolver(vertical);
    }
}
AxisResolverFactory.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AxisResolverFactory.ctorParameters = () => [];
class AxisResolver {
    /**
     * @param {?=} vertical
     */
    constructor(vertical = true) {
        this.vertical = vertical;
    }
    /**
     * @return {?}
     */
    clientHeightKey() { return this.vertical ? 'clientHeight' : 'clientWidth'; }
    /**
     * @return {?}
     */
    offsetHeightKey() { return this.vertical ? 'offsetHeight' : 'offsetWidth'; }
    /**
     * @return {?}
     */
    scrollHeightKey() { return this.vertical ? 'scrollHeight' : 'scrollWidth'; }
    /**
     * @return {?}
     */
    pageYOffsetKey() { return this.vertical ? 'pageYOffset' : 'pageXOffset'; }
    /**
     * @return {?}
     */
    offsetTopKey() { return this.vertical ? 'offsetTop' : 'offsetLeft'; }
    /**
     * @return {?}
     */
    scrollTopKey() { return this.vertical ? 'scrollTop' : 'scrollLeft'; }
    /**
     * @return {?}
     */
    topKey() { return this.vertical ? 'top' : 'left'; }
}

class PositionResolverFactory {
    /**
     * @param {?} axisResolver
     */
    constructor(axisResolver) {
        this.axisResolver = axisResolver;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    create(options) {
        return new PositionResolver(this.axisResolver.create(!options.horizontal), options);
    }
}
PositionResolverFactory.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
PositionResolverFactory.ctorParameters = () => [
    { type: AxisResolverFactory, },
];
class PositionResolver {
    /**
     * @param {?} axis
     * @param {?} options
     */
    constructor(axis, options) {
        this.axis = axis;
        this.options = options;
        this.resolveContainer(this.options.windowElement);
        this.defineContainer(this.options.windowElement);
    }
    /**
     * @param {?} windowElement
     * @return {?}
     */
    defineContainer(windowElement) {
        if (this.resolveContainer(windowElement) || !windowElement.nativeElement) {
            this.container = windowElement;
        }
        else {
            this.container = windowElement.nativeElement;
        }
        return this.container;
    }
    /**
     * @param {?} windowElement
     * @return {?}
     */
    resolveContainer(windowElement) {
        const /** @type {?} */ isContainerWindow = Object.prototype.toString.call(windowElement).includes('Window');
        this.isContainerWindow = isContainerWindow;
        return isContainerWindow;
    }
    /**
     * @return {?}
     */
    getDocumentElement() {
        return this.isContainerWindow
            ? this.options.windowElement.document.documentElement
            : null;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    calculatePoints(element) {
        return this.isContainerWindow
            ? this.calculatePointsForWindow(element)
            : this.calculatePointsForElement(element);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    calculatePointsForWindow(element) {
        // container's height
        const /** @type {?} */ height = this.height(this.container);
        // scrolled until now / current y point
        const /** @type {?} */ scrolledUntilNow = height + this.pageYOffset(this.getDocumentElement());
        // total height / most bottom y point
        const /** @type {?} */ totalToScroll = this.offsetTop(element.nativeElement) + this.height(element.nativeElement);
        return { height, scrolledUntilNow, totalToScroll };
    }
    /**
     * @param {?} element
     * @return {?}
     */
    calculatePointsForElement(element) {
        let /** @type {?} */ scrollTop = this.axis.scrollTopKey();
        let /** @type {?} */ scrollHeight = this.axis.scrollHeightKey();
        const /** @type {?} */ container = this.container;
        const /** @type {?} */ height = this.height(container);
        // perhaps use this.container.offsetTop instead of 'scrollTop'
        const /** @type {?} */ scrolledUntilNow = container[scrollTop];
        let /** @type {?} */ containerTopOffset = 0;
        const /** @type {?} */ offsetTop = this.offsetTop(container);
        if (offsetTop !== void 0) {
            containerTopOffset = offsetTop;
        }
        const /** @type {?} */ totalToScroll = container[scrollHeight];
        return { height, scrolledUntilNow, totalToScroll };
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    height(elem) {
        let /** @type {?} */ offsetHeight = this.axis.offsetHeightKey();
        let /** @type {?} */ clientHeight = this.axis.clientHeightKey();
        // elem = elem.nativeElement;
        if (isNaN(elem[offsetHeight])) {
            return this.getDocumentElement()[clientHeight];
        }
        else {
            return elem[offsetHeight];
        }
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    offsetTop(elem) {
        let /** @type {?} */ top = this.axis.topKey();
        // elem = elem.nativeElement;
        if (!elem.getBoundingClientRect) {
            return;
        }
        return elem.getBoundingClientRect()[top] + this.pageYOffset(elem);
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    pageYOffset(elem) {
        let /** @type {?} */ pageYOffset = this.axis.pageYOffsetKey();
        let /** @type {?} */ scrollTop = this.axis.scrollTopKey();
        let /** @type {?} */ offsetTop = this.axis.offsetTopKey();
        // elem = elem.nativeElement;
        if (isNaN(window[pageYOffset])) {
            return this.getDocumentElement()[scrollTop];
        }
        else if (elem.ownerDocument) {
            return elem.ownerDocument.defaultView[pageYOffset];
        }
        else {
            return elem[offsetTop];
        }
    }
}

class ScrollRegister {
    /**
     * @param {?} options
     * @return {?}
     */
    attachEvent(options) {
        const /** @type {?} */ scroller$ = Observable.fromEvent(options.container, 'scroll')
            .sampleTime(options.throttleDuration)
            .filter(options.filterBefore)
            .mergeMap((ev) => Observable.of(options.mergeMap(ev)))
            .subscribe(options.scrollHandler);
        return scroller$;
    }
}
ScrollRegister.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ScrollRegister.ctorParameters = () => [];

class ScrollResolver {
    constructor() {
        this.lastScrollPosition = 0;
    }
    /**
     * @param {?} container
     * @param {?} config
     * @param {?} scrollingDown
     * @return {?}
     */
    shouldScroll(container, config, scrollingDown) {
        const /** @type {?} */ distance = config.distance;
        let /** @type {?} */ remaining;
        let /** @type {?} */ containerBreakpoint;
        if (scrollingDown) {
            remaining = container.totalToScroll - container.scrolledUntilNow;
            containerBreakpoint = container.height * distance.down + 1;
        }
        else {
            remaining = container.scrolledUntilNow;
            containerBreakpoint = container.height * distance.up + 1;
        }
        const /** @type {?} */ shouldScroll = remaining <= containerBreakpoint;
        this.lastScrollPosition = container.scrolledUntilNow;
        return shouldScroll;
    }
    /**
     * @param {?} container
     * @return {?}
     */
    isScrollingDown(container) {
        return this.lastScrollPosition < container.scrolledUntilNow;
    }
    /**
     * @param {?} container
     * @param {?} config
     * @return {?}
     */
    getScrollStats(container, config) {
        const /** @type {?} */ isScrollingDown = this.isScrollingDown(container);
        const /** @type {?} */ shouldScroll = this.shouldScroll(container, config, isScrollingDown);
        return { isScrollingDown, shouldScroll };
    }
}
ScrollResolver.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ScrollResolver.ctorParameters = () => [];

class InfiniteScrollDirective {
    /**
     * @param {?} element
     * @param {?} zone
     * @param {?} positionResolverFactory
     * @param {?} scrollRegister
     * @param {?} scrollerResolver
     */
    constructor(element, zone, positionResolverFactory, scrollRegister, scrollerResolver) {
        this.element = element;
        this.zone = zone;
        this.positionResolverFactory = positionResolverFactory;
        this.scrollRegister = scrollRegister;
        this.scrollerResolver = scrollerResolver;
        this.scrolled = new EventEmitter();
        this.scrolledUp = new EventEmitter();
        this.infiniteScrollDistance = 2;
        this.infiniteScrollUpDistance = 1.5;
        this.infiniteScrollThrottle = 300;
        this.infiniteScrollDisabled = false;
        this.infiniteScrollContainer = null;
        this.scrollWindow = true;
        this.immediateCheck = false;
        this.horizontal = false;
        this.alwaysCallback = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (typeof window !== 'undefined') {
            const /** @type {?} */ containerElement = this.resolveContainerElement();
            const /** @type {?} */ positionResolver = this.positionResolverFactory.create({
                horizontal: this.horizontal,
                windowElement: containerElement
            });
            const /** @type {?} */ options = {
                container: positionResolver.container,
                filterBefore: () => !this.infiniteScrollDisabled,
                mergeMap: () => positionResolver.calculatePoints(this.element),
                scrollHandler: (container) => this.handleOnScroll(container),
                throttleDuration: this.infiniteScrollThrottle
            };
            this.disposeScroller = this.scrollRegister.attachEvent(options);
        }
    }
    /**
     * @param {?} container
     * @return {?}
     */
    handleOnScroll(container) {
        const /** @type {?} */ scrollResolverConfig = {
            distance: {
                down: this.infiniteScrollDistance,
                up: this.infiniteScrollUpDistance
            }
        };
        const /** @type {?} */ scrollStats = this.scrollerResolver.getScrollStats(container, scrollResolverConfig);
        if (this.shouldTriggerEvents(scrollStats.shouldScroll)) {
            const /** @type {?} */ infiniteScrollEvent = {
                currentScrollPosition: container.scrolledUntilNow
            };
            if (scrollStats.isScrollingDown) {
                this.onScrollDown(infiniteScrollEvent);
            }
            else {
                this.onScrollUp(infiniteScrollEvent);
            }
        }
    }
    /**
     * @param {?} shouldScroll
     * @return {?}
     */
    shouldTriggerEvents(shouldScroll) {
        return (this.alwaysCallback || shouldScroll) && !this.infiniteScrollDisabled;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.disposeScroller) {
            this.disposeScroller.unsubscribe();
        }
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    onScrollDown(data = { currentScrollPosition: 0 }) {
        this.zone.run(() => this.scrolled.emit(data));
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    onScrollUp(data = { currentScrollPosition: 0 }) {
        this.zone.run(() => this.scrolledUp.emit(data));
    }
    /**
     * @return {?}
     */
    resolveContainerElement() {
        const /** @type {?} */ selector = this.infiniteScrollContainer;
        const /** @type {?} */ hasWindow = window && window.hasOwnProperty('document');
        const /** @type {?} */ containerIsString = selector && hasWindow && typeof (this.infiniteScrollContainer) === 'string';
        let /** @type {?} */ container = containerIsString
            ? window.document.querySelector(selector)
            : selector;
        if (!selector) {
            container = this.scrollWindow ? window : this.element;
        }
        return container;
    }
}
InfiniteScrollDirective.decorators = [
    { type: Directive, args: [{
                selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'
            },] },
];
/**
 * @nocollapse
 */
InfiniteScrollDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
    { type: PositionResolverFactory, },
    { type: ScrollRegister, },
    { type: ScrollResolver, },
];
InfiniteScrollDirective.propDecorators = {
    'scrolled': [{ type: Output },],
    'scrolledUp': [{ type: Output },],
    'infiniteScrollDistance': [{ type: Input },],
    'infiniteScrollUpDistance': [{ type: Input },],
    'infiniteScrollThrottle': [{ type: Input },],
    'infiniteScrollDisabled': [{ type: Input },],
    'infiniteScrollContainer': [{ type: Input },],
    'scrollWindow': [{ type: Input },],
    'immediateCheck': [{ type: Input },],
    'horizontal': [{ type: Input },],
    'alwaysCallback': [{ type: Input },],
};

class InfiniteScrollModule {
}
InfiniteScrollModule.decorators = [
    { type: NgModule, args: [{
                declarations: [InfiniteScrollDirective],
                exports: [InfiniteScrollDirective],
                imports: [],
                providers: [
                    AxisResolverFactory,
                    PositionResolverFactory,
                    ScrollRegister,
                    ScrollResolver
                ]
            },] },
];
/**
 * @nocollapse
 */
InfiniteScrollModule.ctorParameters = () => [];

/**
 * Angular library starter.
 * Build an Angular library compatible with AoT compilation & Tree shaking.
 * Written by Roberto Simonetti.
 * MIT license.
 * https://github.com/robisim74/angular-library-starter
 */
/**
 * Entry point for all public APIs of the package.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { InfiniteScrollModule, InfiniteScrollDirective as ɵa, AxisResolverFactory as ɵc, PositionResolverFactory as ɵb, ScrollRegister as ɵd, ScrollResolver as ɵe };
//# sourceMappingURL=ngx-infinite-scroll.js.map
